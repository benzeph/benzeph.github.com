<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Zeph's Blog | Professional Thoughts</title>
	<link rel="stylesheet" type="text/css" href="../css/zeph.css">
	<link href="../css/bootstrap.min.css" rel="stylesheet" media="screen">
	<link href="../css/bootstrap-responsive.css" rel="stylesheet">
	<link type="text/css" rel="stylesheet" href="../css/shCoreDefault.css"/>
	<link id="scrollUpTheme" rel="stylesheet" href="../css/pill.css">
	<link href='http://fonts.googleapis.com/css?family=Cinzel+Decorative:900' rel='stylesheet' type='text/css'>
	<style type="text/css">html{font-family:Arial,Helvetica,sans-serif,"宋体"}</style>
</head>
<body>
	<div class="navbar">
		<div class="navbar-inner">
			<ul class="nav">
				<li>
					<a href="../index.html">
						<span class="muted">文章列表</span>
					</a>
				</li>
				<li class="dropdown">
					<a id="classifyDropdown" href="#" role="button" class="dropdown-toggle" data-toggle="dropdown">
						分类 <b class="caret"></b>
					</a>
					<ul class="dropdown-menu" role="menu" aria-labelledby="classifyDropdown">
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">编码</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">敏捷</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">管理</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">业务</a>
						</li>
						<li role="presentation" class="divider"></li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">其他</a>
						</li>
					</ul>
				</li>
			</ul>
			<ul class="nav pull-right">
				<a class="brand logo" href="../index.html">Zeph</a>
			</ul>
			<div class="navbar-form">
				<input id="searchBox" type="text" class="span2" data-provide="typeahead" data-items="4" data-source='["常用Git开发命令和开发模式指南","Gradle使用指南（译）","代码整洁","用户故事与敏捷方法(1)","用户故事与敏捷方法(2)","用户故事与敏捷方法(3)","测试驱动开发","持续集成CI","Maven的使用","实现模式"]'>
				<button class="btn" onclick="goToArticle()">Go</button>
			</div>
		</div>
	</div>
	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span9">
				<div class="article">
					<h1>实现模式</h1>
					<p> <h3>5.1类</h3>
					</p>

					<p>数据的变化比逻辑要频繁的多。类是相对昂贵的设计元素，它应该做一些有直接而明显意义的事情。</p>

					<p> <h3>5.2简单的超类名</h3>
					</p>

					<p>给计算逻辑找到强有力的隐喻。</p>

					<p>重要的类，尽量用一个单词来为它命名。</p>

					<p>
						<h3>5.3限定性的子类名</h3>
					</p>

					<p>
						子类的名字有两个重要的职责，不仅要描述这些类像什么，还要说明他们之间的区别是什么。通常在超类名的基础上扩展一两个词就可以得到子类名。
					</p>

					<p>
						这条规则也有例外：如果继承只是用作共享机制，并且子类本身代表着一个重要概念，那么这样的子类就应该被视为它自己的继承体系的根，拥有一个简单的名字。
					</p>

					<p>
						<h3>5.4抽象接口</h3>
					</p>

					<p>针对接口编程，不要针对实现编程。设计决策不应该暴露给不必要的地方。</p>

					<p>接口是指“一组没有实现的操作”。</p>

					<p>并不是接口数量越多软件成本就越少，只有需要接口带来的灵活性时才值得为它付出成本。</p>

					<p>为了降低成本，最好是在真正需要这种灵活性时再引入接口。</p>

					<p>需求和技术都在以不可预测的方式变化。</p>

					<p>通过预先思考来弄清软件将来的样子，其效果是相当有限的。</p>

					<p>应该在确认无疑需要灵活性时，才应该引入这种灵活性。</p>

					<p>
						<h3>5.5interface</h3>
					</p>

					<p>对接口本身的修改是不被鼓励的。</p>

					<p>所有的操作都是public。</p>

					<p>把interface看做没有实现的类，就按照类的命名方式命名。</p>

					<p>有必要加一个I在前面。以免它占据了类的最好命名。</p>

					<p>
						<h3>5.6抽象类</h3>
					</p>

					<p>何时应该使用超类，何时应该使用interface。归于两点：接口会如何变化，实现类是否需要同时支持多个接口。</p>

					<p>
						如果抽象接口需要支持实现的变化以及接口本身的变化两种类型，则interface对后者的支持不佳，因为一旦改变interface，所有实现类都要改变。
					</p>

					<p>抽象类的局限体现在实现类必须对其忠贞不二。如果需要以另一种视角来看待同一个实现类，就只能让他实现interface。</p>

					<p>
						只要有可能让继承体系根上的类被独立创建和使用，就应该这样做。一旦走上抽象化这条路，就容易划得太远而创造出没有价值的抽象。努力让继承体系的根也能独立创建，可以促进你消除那些不必要的抽象。
					</p>

					<p>
						<h3>5.7有版本的interface</h3>
					</p>

					<p>
						如果想要修改一个interface但又不能修改，怎么办？这种情况通常在想要增加操作时发生，在interface中增加操作会破坏所有现有的实现类，所以不能这样做。
					</p>

					<p>
						可以声明一个新的interface，使它继承原来的interface，然后添加操作。使用者需要新的功能，就是用这个新的interface，其他使用者无视这个新的interface。
					</p>

					<p>
						<h3>5.8值对象</h3>
					</p>

					<p>
						把具有可变状态的对象作为思考计算问题的一种方式确实很有价值，但它并非唯一的方式。在数学中一个数加1，这个数本身没有改变，只是创建了一个新的值。
					</p>

					<p>函数式的计算风格永远不会改变任何状态，只是创建新的值。</p>

					<p>要实现一个值对象，需要首先在“状态的世界”和“值的世界”之间画出一条边界。</p>

					<p>
						值对象的所有状态都应该在构造器中传入，其他地方不再提供改变其内部状态的方式。对值对象的操作总是返回新的对象，操作的发起者要自己保存返回的对象。
					</p>

					<p>
						<h3>5.9特化</h3>
					</p>

					<p>最简单的变化是状态的差异。</p>

					<p>最复杂的变化是在逻辑上完全不同。</p>

					<p>大多数的程序位于两个极端——“相同的逻辑处理不同的数据”和“不同的逻辑处理相同的数据”之间的某个位置。</p>

					<p>
						<h3>5.10子类</h3>
					</p>

					<p>
						<h3>5.11实现器</h3>
					</p>

					<p>在由对象组成的程序中，多态消息是表达选择的基本方法之一。</p>

					<p>
						把同一个协议实现多次所表达的意思是：从计算的这一方面来看，只要某些符合代码意图的事情发生就可以了，至于“到底发生了什么”，我们并不关心。
					</p>

					<p>
						<h3>5.12内部类</h3>
					</p>

					<p>有时候需要把一部分逻辑封装起来，但又不想新建一个文件来安置全新的类。</p>

					<p>如果要让内部类与其所处的对象的实例完全分离，可以将其声明为static。</p>

					<p>
						<h3>5.13实例特有的行为</h3>
					</p>

					<p>为了让代码更容易被读懂，即便是实例特有的行为，也最好是在对象被创建之初就确定下来，之后不再改变。</p>

					<p>
						<h3>5.14条件语句</h3>
					</p>

					<p>条件语句是实现实例特有行为的最简单方法。但当条件语句重复，情况就很糟糕了。</p>

					<p>
						解决这个问题的方法是把条件逻辑变成消息，发送给子类或者委派。如果条件逻辑出现重复，或者各个条件分支上的逻辑差异很大，那么用消息的方式来描述会比显示的条件逻辑更好。频繁变化的条件逻辑也最好是用消息来表现，这样就可以使各个分支的修改更简单，对其他分支的影响更小。
					</p>

					<p>
						<h3>5.15委派</h3>
					</p>

					<p>要让不同的实例执行不同的逻辑，另一种办法就是把部分工作委派给不同的类型的对象。</p>

					<p>使用委派有一个常用技巧：把发起委派的对象作为参数传递给接收委派的方法。</p>

					<p>有时委派对象需要给自己发送消息，这个“自己”是有二义性的：有时候消息应该送给发起委派的对象，有时候消息应该送给委派对象。</p>

					<p>
						<h3>5.16可插拔的选择器</h3>
					</p>

					<p>
						假设我们需要实例特有的行为，但只需要在一两个方法中体现，并且你也并不介意把各种变化情况的代码都放在一个类里。在这种情况下，可以把要调用的方法名保存在实例变量中，然后通过反射来调用该方法。
					</p>

					<p>
						<h3>5.17匿名内部类</h3>
					</p>

					<p>创建一个“只在一处使用”的类，这些类可以覆盖一个或者多个方法，完全为了当前的用途。</p>

					<p>
						<h3>5.18库类</h3>
					</p>

					<p>如果某些功能放在哪个对象中都不合适，那么该把它们放在哪里呢？一个办法是在一个空类中创建</p>
				</div>
				<div id="comments">
					<!-- Duoshuo Comment BEGIN -->
					<div class="ds-thread"></div>
					<script type="text/javascript">
					var duoshuoQuery = {short_name:"benzeph"};
						(function() {
							var ds = document.createElement('script');
							ds.type = 'text/javascript';ds.async = true;
							ds.src = 'http://static.duoshuo.com/embed.js';
							ds.charset = 'UTF-8';
							(document.getElementsByTagName('head')[0] 
							|| document.getElementsByTagName('body')[0]).appendChild(ds);
						})();
					</script>
					<!-- Duoshuo Comment END -->
				</div>
				<div class="footer">
					本博客基于
					<a href="http://twitter.github.io/bootstrap/index.html">Bootstrap</a>
					框架开发，使用
					<a href="https://code.google.com/p/google-code-prettify/">google-code-prettify</a>
					做代码展示，部署在
					<a href="http://pages.github.com/">Github Page</a>
					上，欢迎大家访问
				</div>
			</div>
		</div>
	</div>
	<script type="text/javascript" src="../js/zeph.js"></script>
	<script type="text/javascript" src="../js/bootstrap.min.js"></script>
	<script type="text/javascript" src="../js/jquery.min.js"></script>
	<script type="text/javascript" src="../js/jquery.min.js"></script>
	<script type="text/javascript" src="../js/jquery.scrollUp.min.js"></script>
	<script type="text/javascript" src="../js/bootstrap-dropdown.js"></script>
	<script type="text/javascript" src="../js/bootstrap-typeahead.js"></script>
	<script type="text/javascript">
		$(function () {
			$.scrollUp();
		});
	</script>
</body>
</html>