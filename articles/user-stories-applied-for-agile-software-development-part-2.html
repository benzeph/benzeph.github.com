<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>Zeph's Blog | Professional Thoughts</title>
	<link rel="stylesheet" type="text/css" href="../css/zeph.css">
	<link id="scrollUpTheme" rel="stylesheet" href="../css/pill.css">
	<link href="../css/bootstrap.min.css" rel="stylesheet" media="screen">
	<link href="../css/bootstrap-responsive.css" rel="stylesheet">
	<link href='http://fonts.googleapis.com/css?family=Cinzel+Decorative:900' rel='stylesheet' type='text/css'>
	<style type="text/css">body{font-family:Arial,Helvetica,sans-serif,"宋体"}</style>
</head>
<body>
	<div class="navbar">
		<div class="navbar-inner">
			<ul class="nav">
				<li>
					<a href="../index.html">
						<span class="muted">文章列表</span>
					</a>
				</li>
				<li class="dropdown">
					<a id="classifyDropdown" href="#" role="button" class="dropdown-toggle" data-toggle="dropdown">
						分类 <b class="caret"></b>
					</a>
					<ul class="dropdown-menu" role="menu" aria-labelledby="classifyDropdown">
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">编码</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">敏捷</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">管理</a>
						</li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">业务</a>
						</li>
						<li role="presentation" class="divider"></li>
						<li role="presentation">
							<a role="menuitem" tabindex="-1" href="#">其他</a>
						</li>
					</ul>
				</li>
			</ul>
			<ul class="nav pull-right">
				<a class="brand logo" href="../index.html">Zeph</a>
			</ul>
			<div class="navbar-form">
				<input id="searchBox" type="text" class="span2" data-provide="typeahead" data-items="4" data-source='["常用Git开发命令和开发模式指南","Gradle使用指南（译）","代码整洁","用户故事与敏捷方法(1)","用户故事与敏捷方法(2)","用户故事与敏捷方法(3)","测试驱动开发","持续集成CI","Maven的使用","实现模式"]'>
				<button class="btn" onclick="goToArticle()">Go</button>
			</div>
		</div>
	</div>
	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span9">
				<div class="article">
					<h1>用户故事与敏捷方法(2)</h1>
					<div class="well">
						续上一部分
						<a href="user-stories-applied-for-agile-software-development-part-1.html">用户故事与敏捷方法(1)</a>
					</div>
					<p> <h2>8 估算用户故事</h2>
					</p>

					<p>估算故事的最好方法具有如下特点：</p>

					<p>(1)    无论什么时候获得有关故事的新信息，都允许我们改变之前的想法</p>

					<p>(2)    适用于史诗故事和小故事</p>

					<p>(3)    不需要花很多时间</p>

					<p>(4)    提供进度和剩余工作的有用信息</p>

					<p>(5)    不太精确的估算也不会有太大问题</p>

					<p>(6)    可以用来定制发布计划</p>

					<p> <h4>故事点</h4>
					</p>

					<p>
						故事点有个很好的特性是团队可以定义自己认为合适的故事点。一个团队可能决定定义一个故事点为一个理想日的工作（也就是说，一天中没有任何干扰，没有会议，没有电子邮件，没有电话等等）。另一个团队可能定义一个故事点为一个理想周的工作。团队还可能把一个故事点作为故事复杂度的测量。
					</p>

					<p>
						虽然极少会有这样的理想日，但是用理想时间考虑故事有两种好处。第一，相较于用连续时间估算，它更简单。用持续时间估算迫使我们考虑对时间的各种可能的影响。第二，相较于用完全模糊单位，用理想日估算故事点可使我们的估算拥有更好的依据。
					</p>

					<p>估算的主要目的之一是知道整个项目的工作量，所以最后我们总是要将估算换算成时间。</p>

					<p>
						<h4>以团队估算</h4>
					</p>

					<p>故事估算应该由整个团队集体完成。原因有两个：</p>

					<p>(1)    还不确定团队中谁负责完成这个故事，所以应该把故事分配给整个团队而不是个人</p>

					<p>(2)    团队决定的估算可能比个人估算更有用</p>

					<p>
						<h4>估算</h4>
					</p>

					<p>使用迭代方法进行估算。具体方法如下：</p>

					<p>
						(1)聚集所有参与故事估算的客户和开发人员。客户随机抽取一个故事，读给开发人员听。开发人员根据需要尽可能多发问，客户要尽其所能解答。如果客户不知道答案，可以先猜猜看，或者要团队对持估算这个故事。
					</p>

					<p>
						所有事情都要花4小时：程序员估算一个故事时，他们应该考虑完成这个故事需做的所有事情。他们要考虑测试代码，和客户讨论，可能帮助客户计划或自动化验收测试等诸多因素。如果他们不讲这些考虑在内。
					</p>

					<p>
						(2)    如果对故事没有疑问，每个开发人员在卡上写下一个估算值，先不要给其他人看。假如团队定义一个故事点为一个理想日的工作，开发人员则想象完成故事需要多少理想日。
					</p>

					<p>
						(3)    大家都写好估算值后，所有人翻开他们的卡片或者拿起展示给所有人看。这时，估算值很有可能相差很大。这是件好事。如果估算值不同，估算值高的和低的再解释一下估算依据。（耐性倾听别人的想法很重要）
					</p>

					<p>
						(4)    在讨论完故事后，开发人员再次将估算值写在卡片上。当大家都写好修改好的估算值，将卡片再次展示给所有人看。许多情况下，第二轮估算值就差不多一样了。但是如果没有，重复让估高和估低的人解释他们的想法。多数情况下，估高和估低的人会改变他们的估算。
					</p>

					<p>
						我们的目的是要为故事得到一个统一的估算值。这个过程至少会超过3轮。但是只要估算在不断接近一致，那么我们就继续这个过程。没有必要让所有人都在卡片上写下完全一样的估算值。点数要合理而不是绝对精准。
					</p>

					<p>
						<h4>三角测量</h4>
					</p>

					<p>
						在做了几个估算后，我们可以（而且必要）对估算做三角测量。具体做法就是在估算一个故事时，根据这个故事与其他一个或多个故事的关系来估算。
					</p>

					<p>
						三角测量是帮助团队验证他们没有逐渐改变一个故事点含义的有效方法。将故事卡根据它们的大小贴在墙上是三角测量的好方法（也就是分类）。在墙上画出竖线，标出每列的故事点，然后将故事卡贴到相应的列中。依据这种分类的方式，可以将同类的卡片作对比，比较估算该故事是否和其他同类故事大致相同。
					</p>

					<p>
						<h4>使用故事点</h4>
					</p>

					<p>
						在一轮迭代结束时，团队计算已完成的故事点数。因为即将到来的迭代也是同样的长度，这个点数可以将作为下轮迭代将完成的故事点数的预报。
					</p>

					<p>一轮的迭代估算，有三个条件：</p>

					<p>(1)    这轮迭代中没有发生任何异常事件（加班，多了程序员等），因此生产力没有受到影响。</p>

					<p>(2)    必须采用前后一致的方式进行估算。</p>

					<p>(3)    第一轮迭代的故事必须是独立。因为一轮中糟糕的故事会导致迭代速率的错误判断。</p>

					<p>
						<h4>一些提醒</h4>
					</p>

					<p>
						(1)    你的团队的故事点和我的团队的故事点是不一样的。你的团队估算的故事有3个故事点，可能我的团队估算有5个故事点。
					</p>

					<p>(2)    一个故事分解成一些小故事后，这些小故事估算的总和不需要与开始那个故事的估算相等。</p>

					<p>(3)    类似的，一个故事分解成一些任务。这些任务估算的总和不需要与故事的估算相等。</p>

					<p>
						<h2>9 发布计划</h2>
					</p>

					<p>
						以产品的开发路线图开始规划发布通常很有帮助，路线图展示未来几个新发布中关注的重点。这个产品的开发路线图毫无疑问会不断改变——这是我们所期望的，因为这些改变表明我们更加了解自己的产品、它的市场以及我们开发产品的能力。
					</p>

					<p>产品的开发路线图可以很简单，它可以是未来几个发布要关注的重点列表，或者像Kent Beck所称的“主题”。</p>

					<p>从一份笼统的开发路线图开始，我们使用以下两个问题来启动发布计划。</p>

					<p>(1)    我们在想什么时候发布</p>

					<p>(2)    每个故事的优先级是什么</p>

					<p>
						一旦得到这些问题的答案，就可以通过估算团队能在每轮迭代中完成多少工作来计划发布了。利用我们能在每一轮迭代中完成多少工作量的估算，我们可以做一个合理的预测，即完成符合用户期望的发布需要多少轮迭代。
					</p>

					<p>
						<h4>我们想在什么时候发布</h4>
					</p>

					<p>理想状况下，开发人员和客户可以谈一个日期范围，而不是一个具体日期。</p>

					<p>可迭代的、由故事驱动的过程使我们很容易确定一个日期，确定在指定日期里交付哪些功能却比较困难。</p>

					<p>如果一个团队做发布计划时能以一个可接受的日期范围为起点，那么他们的发布时间将更灵活。</p>

					<p>
						在某些案例中，日期确实是固定的。最常见的情况是，为行业展览准备的发布、关键客户的发布或者类似的其他里程碑式的版本。如果这样，发布计划实际上会更容易，因为要考虑的因素较少。但是，决定在发布中包含哪些故事通常更加困难。
					</p>

					<p>
						<h4>希望在发布中包含哪些功能？</h4>
					</p>

					<p>DSDM包括一个排列优先级的方法，称之为莫斯科（MoSCoW）规则。MoSCoW的缩写是：</p>

					<p>(1)    必须有 must have</p>

					<p>(2)    应该有 should have</p>

					<p>(3)    可以有 could have</p>

					<p>(4)    这次不会有 won’t have this time</p>

					<p>
						“必须有的功能”是指系统的基本功能。“应该有的功能”是指很重要但短期内有代替解决方案的功能。如果项目没有时间约束，通常认为应该有的功能是强制性的。“可以有的功能”是指如果没时间就可以在发布中不予考虑的功能。“不会有的功能”是客户期望拥有但同时承认需要在后续发布中实现的功能。
					</p>

					<p>
						<h4>排列故事优先级</h4>
					</p>

					<p>我们可以通过多个维度来为故事拍优先级。</p>

					<p>可以利用的技术要素：</p>

					<p>(1)    故事不能如期完成的风险</p>

					<p>(2)    推迟实现一个故事时对其他故事的影响</p>

					<p>客户和用户对故事进行优先级排序，也会有自己的要素：</p>

					<p>(1)    故事对于广泛用户或客户的重要性</p>

					<p>(2)    故事对于少部分重要用户或客户的重要性</p>

					<p>(3)    故事与其他故事的内聚性</p>

					<p>
						总的来说，开发人员实现故事时会有一个顺序，就像客户所希望的那样。当客户和开发人员对这个顺序有不同意见时，最后每次都应用是客户说了算。但客户在没有从开发团队那里获得某些信息之前，很难确定故事的优先级。至少，客户要知道每个故事需要大约多久才能完成。
					</p>

					<p>
						此时，客户不会把对故事的估算加起来，然后决定一个发布中包括什么，不包括什么。而是利用这些估算，结合自己对于每个故事价值的评估，把故事进行优先级排序，使交付给自己公司的价值最大化。
					</p>

					<p>
						<h4>混合优先级</h4>
					</p>

					<p>如果客户在确定一个故事的优先级时遇到问题，可能需要分割这个故事。分割故事能使客户对独立的故事排列出不同的优先级。</p>

					<p>
						<h4>高风险故事</h4>
					</p>

					<p>
						敏捷方法旗帜鲜明地支持先做最有价值的部分。这让敏捷项目能够避免过早地解决风险，同时也推迟了可能并不需要的一些基础性代码的开发。赞同先做最有价值的部分，还可能尽早使项目发布，那时只提供最有价值的功能。
					</p>

					<p>
						但是，即使以价值优先为导向，我们在排列故事优先级时仍然需要考虑风险。许多开发人员倾向于先做风险最高的故事。有时这是恰当的，但这仍然必须由客户决定。然而，在排列故事优先级时，客户应该考虑技术团队的意见。
					</p>

					<p>
						<h4>根据架构需要安排优先级</h4>
					</p>

					<p>高风险故事经常与基础性或非功能性需求相关，如性能需求。</p>

					<p>
						在某些情况下，很容易重构系统以改善其扩展性。但在另一些情况下，重构可能会非常困难。开发人员应该帮助客户识别那些可以推迟实现，但越晚实现开发成本可能会非常高的故事。但是，开发人员不能滥用这种影响力，引导客户同意尽早实现他们喜欢的技术性功能。
					</p>

					<p>
						<h4>选择迭代长度</h4>
					</p>

					<p>
						开发人员和客户共同选择合适他们的迭代长度。迭代长度通常为1至4周。短迭代允许项目更加频繁地做出调整，项目进度也会更加透明；但是每轮迭代会有少许额外开销。假如不确定迭代长度，请选择短迭代而不是长迭代，使用长迭代更容易犯错。
					</p>

					<p>
						在项目开发期间，尽可能地坚持固定的迭代长度。有了一致的迭代长度，项目会有固定的节奏，这有利于团队的开发速度。当然有时需要改变迭代长度。
					</p>

					<p>
						<h4>从故事点到预计工期</h4>
					</p>

					<p>
						假设客户已经安排好所有故事的优先级。团队累加每个卡片的估算，总共有100个故事点。使用故事点使得所有故事变得容易，但现在我们需要一种方法，将故事转换成项目的预计工期。
					</p>

					<p>答案当然是使用速率。通过总的故事点除以速率，得到迭代的轮次。</p>

					<p>
						<h4>初始速率</h4>
					</p>

					<p>可以通过以下三种方式获得初始速率：</p>

					<p>(1)    使用历史值</p>

					<p>(2)    执行一轮初始迭代，使用那轮迭代的速率</p>

					<p>(3)    猜测</p>

					<p>使用历史值无疑是最好的选择，但仅适合于现有团队刚好做过类似的项目且没有成员加入或离开时。</p>

					<p>执行一轮迭代以获取初始速率是一个很好的方法。但是很多时候，这个方法并不可行。</p>

					<p>在不能执行初始迭代时，只能猜测速率。</p>

					<p>
						<h4>猜测速率</h4>
					</p>

					<p>如果我们需要猜测速率，这种方法至少应该是言之有理的，能清楚地跟别人解释。</p>

					<p>
						如果故事点是一个理想工作日，我们可以通过估算完成一个完整的理想工作日实际需要多少天来估算初始速率。在迭代过程中，团队显然会受到许多干扰，阻止团队享受理想日，他们的实际工作日会与理想日有所不同。由于这些干扰，把一轮迭代三分之一到一半的开发日作为预计速率是很常见的。
					</p>

					<p>
						当然，随着项目进行过几轮迭代以后，团队对于项目开发工期会获得更多经验。他们会知道在一轮或两轮迭代里面，实际速率与估算速率相差多少，并且能够以此改善估算。
					</p>

					<p>
						<h4>建发布计划</h4>
					</p>

					<p>
						发布计划的最后一步是把故事分配到每轮迭代中。客户和开发人员一起协作，选择优先级最高的20个故事点（速率：一轮迭代20个故事点），并且将它们放入到第一轮迭代中。下一组次高优先级的20个故事点放入第二轮迭代，以此类推，直到完成所有的故事分配。
					</p>

					<p>根据参与人员的不同（包括工作地点），有许多方法可以沟通发布计划：</p>

					<p>(1)    对于工作在一起的团队，我们把故事卡钉在墙上，用列来表示迭代</p>

					<p>(2)    对于记录在电子表格中的故事，我们根据它们的迭代进行排序，然后再每轮迭代的最后一个故事后画一条厚重的粗线</p>

					<p>(3)    对于有兴趣的远程利益相关者，我们复印记录卡给他们</p>

					<p>
						(4)    对于有兴趣的，比较讲究形式的远程利益者，我们给他们创建简单的甘特图。创建如“迭代1”的入口，然后在下方列出那轮迭代中所有故事的名字
					</p>

					<p>
						<h2>10 迭代计划</h2>
					</p>

					<p>在开始一轮迭代的时候，再做进一步的计划也很重要。</p>

					<p>迭代计划概览</p>

					<p>整个团队通过举行迭代计划会议来为下一轮迭代做计划。</p>

					<p>迭代计划会议的一般内容如下：</p>

					<p>(1)    讨论故事</p>

					<p>(2)    从故事中分解出任务</p>

					<p>(3)    开发人员承担每个任务的责任</p>

					<p>(4)    讨论过所有故事，并且接收所有任务后，开发人员单独估算他们承担的任务，以确保他们不会做出过于乐观的承诺</p>

					<p>
						<h4>讨论故事</h4>
					</p>

					<p>
						迭代计划会议是客户为团队调整故事优先级的最佳时间。客户从最高优先级的故事开始，读给开发人员听。有开发人员提问，直到他们充分理解故事，能够故事中分解出任务。（没有必要理解故事的所有细节，过分地深入每个故事的细节会让会议编程冗长、低效，因为会议中不是每个人都需要聆听所有故事的所有细节。）
					</p>

					<p>
						<h4>分解任务</h4>
					</p>

					<p>为什么要做分解？为什么不直接把故事作为独立的工作单位呢？</p>

					<p>(1)    术业有专攻，实现故事的开发人员不止一个，划分工作更有益于最快完成</p>

					<p>
						(2)    故事是对用户或客户有价值的功能的描述，不是开发人员的To-Do-List（Task）。分解故事有利于发现那些容易被遗忘的任务。
					</p>

					<p>当不同的团队成员说明构成故事的任务时，团队中需要有人记录下这些任务。</p>

					<p>
						<h4>准则</h4>
					</p>

					<p>因为故事已经很小了，所以没有必要围绕任务的期望大小设定非常精确的准则。</p>

					<p>(1)    如果故事的某个任务特别难于估算，就把那个任务从故事的其余任务中分离出来。</p>

					<p>(2)    倘若有些任务可以很容易安排给多名开发人员共同完成，就分割它们。</p>

					<p>(3)    若有必要让客户了解故事某一部分的完成情况，可以把那部分拿出来作为一个任务。</p>

					<p>
						<h4>承担责任</h4>
					</p>

					<p>一旦确定故事的所有任务，就需要有团队成员自愿执行每个任务。</p>

					<p>每个任务通常也最好只关联一个人的名字，即使采用结对编程。</p>

					<p>确保完成任务是团队中每个人的责任。如果有开发人员不能完成它接手的所有任务，团队中的其他成员应该尽量用于承担。</p>

					<p>虽然任务是每个人认领的，但是在迭代期间，这并不是一成不变的。可能有些工作比预想的简单，但有些却比预想的困难。</p>

					<p>在迭代结束时，不应该有人说“我完成了我的工作，但是Tom还有一些任务没有完成”</p>

					<p>
						<h4>估算并确认</h4>
					</p>

					<p>每个开发人员负责估算自己承担的工作量。最好的方法仍是以理想时间来估算。</p>

					<p>此时任务应该足够小，以便做出可靠的估算。但即使不行，也不必担心。预测一下任务完成需要多长时间，然后继续前进。</p>
					<p>
						<table class="table table-striped">
							<tr>
								<th>#</th>
								<th>任务</th>
								<th>负责人</th>
								<th>估算时间（单位：故事点）</th>
							</tr>
							<tr>
								<td>1</td>
								<td>编写搜索博文框</td>
								<td>Zeph</td>
								<td>10</td>
							</tr>
							<tr>
								<td>2</td>
								<td>编写博文的“关于我”分栏内容</td>
								<td>Zeph</td>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
								<td>修改博文“用户故事”的排版格式</td>
								<td>Zeph</td>
								<td>10</td>
							</tr>
						</table>
					</p>
					<p>一旦开发人员估算好自己的每个任务，就需要把这些估算加起来，进而做出实际的评估，看看在迭代中能够完成所有的任务。</p>

					<p>如果没有把握在这些任务上投入那么多时间，有以下几种选择：</p>

					<p>(1)    留着所有任务，寄希望于一切顺利</p>

					<p>(2)    请求团队中其他成员接手一些我的任务</p>

					<p>(3)    与客户讨论，放弃一个故事（或者分割故事）</p>

					<p>
						<h2>11 测量并监控速率</h2>
					</p>

					<p>一轮迭代完成的故事点就是项目的速率。</p>

					<p>
						<h4>测量速率</h4>
					</p>

					<p>
						列出一轮迭代完成的故事点数的总和。如果发布计划假定的速率和这个速率差别很大，就有必要重新审视项目计划。但是，注意不要过早地调整发布计划。不仅仅因为是最初的速率往往不准确，而且速率在初期的迭代中也很不稳定。可能需要两三轮迭代之后，才能获得一个长期的、比较稳定的速率。
					</p>

					<p>不要讲尚未全部完成的故事也计算在速率中。原因如下：</p>

					<p>(1)    不能计算故事已完成的百分比</p>

					<p>(2)    不希望将带小数点的故事点计算进去，引入错误的精度</p>

					<p>(3)    没完成的故事通常并不能给用户或客户带来任何价值</p>

					<p>(4)    既然一个故事大到包含一个影响速率的子故事，那只能说明这故事确实太大了</p>

					<p>如果实在想在计算速率的时候把部分完成故事的工作计算在内，可以先评估一下故事的平均大小，争取以后把故事划分得更小。</p>

					<p>
						另外，如果经常发现迭代结束时有太多尚未全部完成的故事，这可能是团队内部缺乏合作的一个信号。团队集中力量一起完成一些故事比只完成部分更有价值。
					</p>

					<p>
						<h4>计划速率和实际速率</h4>
					</p>

					<p>监测实际速率和计划速率的偏差，是否需要采取什么措施摆正合理的速率。</p>

					<p>一个比较好的方法是为每轮迭代画出计划速率和实际速率。</p>

					<p>累积故事点图表明了在每轮迭代结束时总共完成的故事点数。</p>

					<p>要同时查看速率曲线和故事点曲线</p>

					<p>
						<h4>迭代燃尽图</h4>
					</p>

					<p>另外一个监控进展的好方法就是迭代燃尽图。迭代燃尽图展示了以故事点表示的每轮迭代末尾剩余的工作量。</p>

					<p>我们不能从燃尽图得到团队前进的速度。因为客户可能随时添加故事点，所以故事点有时会在一轮迭代后增加。</p>

					<p>
						<h4>迭代中的燃尽图</h4>
					</p>

					<p>
						燃尽图不仅可以用于在迭代结束时跟踪进展，它还是迭代期间一种很好的团队自管理工具。在迭代中，每日燃尽图可以展现在迭代内剩余的估算小时。
					</p>

					<p>设计及检测一个平均每个故事点出现的缺陷数目的图表可以帮助我们发现团队速率的提高是不是以牺牲质量为代价的。</p>

				</div>
				<div id="comments">
					<!-- Duoshuo Comment BEGIN -->
					<div class="ds-thread"></div>
					<script type="text/javascript">
						var duoshuoQuery = {short_name:"benzeph"};
							(function() {
								var ds = document.createElement('script');
								ds.type = 'text/javascript';ds.async = true;
								ds.src = 'http://static.duoshuo.com/embed.js';
								ds.charset = 'UTF-8';
								(document.getElementsByTagName('head')[0] 
								|| document.getElementsByTagName('body')[0]).appendChild(ds);
							})();
						</script>
					<!-- Duoshuo Comment END -->
				</div>
				<div class="footer">
					本博客基于
					<a href="http://twitter.github.io/bootstrap/index.html">Bootstrap</a>
					框架开发，使用
					<a href="https://code.google.com/p/google-code-prettify/">google-code-prettify</a>
					做代码展示，部署在
					<a href="http://pages.github.com/">Github Page</a>
					上，欢迎大家访问
				</div>
			</div>
		</div>
	</div>
	<script type="text/javascript" src="../js/zeph.js"></script>
	<script type="text/javascript" src="../js/bootstrap.min.js"></script>
	<script type="text/javascript" src="../js/jquery.min.js"></script>
	<script type="text/javascript" src="../js/jquery.scrollUp.min.js"></script>
	<script type="text/javascript" src="../js/bootstrap-dropdown.js"></script>
	<script type="text/javascript" src="../js/bootstrap-typeahead.js"></script>
	<script type="text/javascript">
		$(function () {
			$.scrollUp();
		});
	</script>
</body>
</html>