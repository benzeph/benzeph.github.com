<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Zeph's Blog</title>
	<link rel="stylesheet" type="text/css" href="../css/zeph.css">
	<link href="../css/bootstrap.min.css" rel="stylesheet" media="screen">
	<link href="../css/bootstrap-responsive.css" rel="stylesheet">
	<link type="text/css" rel="stylesheet" href="../css/shCoreDefault.css"/>
	<link id="scrollUpTheme" rel="stylesheet" href="../css/pill.css">
	<style type="text/css">html{font-family:Arial,Helvetica,sans-serif,"宋体"}</style>
</head>
<body>
	<div class="navbar">
		<div class="navbar-inner">
			<ul class="nav">
				<li >
					<a href="../index.html">文章列表</a>
				</li>
			</ul>
		</div>
	</div>
	<div class="container-fluid">
		<div class="row-fluid">
			<div class="span12">
				<div class="article">
					<h1>代码整洁（Clean Code）</h1>
					<div class="well">
						<p> <strong>代码整洁之道</strong>
							是一本关于软件代码质量的书。但它不仅仅是一本关于如何写出漂亮的变量命名，如何正确组织代码的格式和如何写出简短的函数和类的书。我认为大多数的程序员都应该花一些时间大致的读一下这本书，如果你敏捷开发和TDD使用者和拥护者，就更应该认认真真的阅读这本书。
						</p>
						<p> <strong>软件质量</strong>
							不但依赖于架构及项目管理，而且与代码质量紧密相关。这一点，无论是敏捷开发流派还是传统开发流派，都不得不承认。《代码整洁之道》提出一种观念：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，《代码整洁之道》作者给出了一系列行之有效的整洁代码操作实践。这些实践在《代码整洁之道》中体现为一条条规则(或称“启示”)，并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。		——————《代码整洁之道》
						</p>

					</div>
					<blockquote>
						<p>
							<strong>2 有意义命名</strong>
						</p>

						<blockquote>
							<p>
								<strong>2.2名副其实</strong>
							</p>

							<p>
								<strong>2.3避免误导</strong>
							</p>

							<blockquote>
								<p>(1) 缩写容易让人误解</p>

								<p>(2) 避免变量名中含有Java类型关键字，除非它确实是这个类型。</p>

								<p>(3) 避免变量名太相似</p>
							</blockquote>

							<p>
								<strong>2.4做有意义的区分</strong>
							</p>

							<blockquote>
								<p>(1) 不要简单的以添加数字作为两个不同变量的区分</p>

								<p>(2) 不用说废话。例如：NameString，难道Name还会是浮点数。</p>
							</blockquote>

							<p>
								<strong>2.5 使用读得出来的名称</strong>
							</p>

							<blockquote>
								<p>(1) 少用缩写</p>
							</blockquote>

							<p>
								<strong>2.6 使用可搜索的名称</strong>
							</p>

							<blockquote>
								<p>(1) 如果变量或常量可能在代码的多处使用，则应该给它一个便于搜索的名称。名称长度应与其作用域大小相对应。</p>
							</blockquote>

							<p>
								<strong>2.7 避免使用某种形式的编码</strong>
								（不要让新人除了应付代码之外，还要搞懂另一种“语言”）
							</p>

							<blockquote>
								<p>
									(1) Java程序不需要类型编码。例如：PhoneNumber和PhoneString，当变量类型改变了，还要改变变量的命名，否则会导致误解。
								</p>

								<p>(2) 不必用成员前缀。</p>

								<p>(3) 接口和实现的命名。</p>
							</blockquote>

							<p>
								<strong>2.8避免思维映射</strong>
							</p>

							<blockquote>
								<p>(1)不应当让读者在脑中把你的名称翻译为他们熟知的名称。</p>
							</blockquote>

							<p>
								<strong>2.9类名和对象名应该是名词或者名词短语。</strong>
								避免Manager、Processor这样的类名
							</p>

							<p>
								<strong>2.10方法名应当是动词或者动词短语</strong>
							</p>

							<p>
								<strong>2.11别扮可爱，名字不要太耍宝</strong>
							</p>

							<p>
								<strong>2.12每个概念对应一个词，并保持一致</strong>
							</p>

							<p>
								<strong>2.13别用双关语</strong>
								，避免同一个单词用于不同目的
							</p>

							<p>
								<strong>2.14使用解决方案领域名称</strong>
								（技术性单词）
							</p>

							<p>
								<strong>2.15使用源自所涉及问题领域的名称</strong>
							</p>

							<p>
								<strong>2.16添加有意义的语境</strong>
								（给予这个变量一个适当的环境，例如：放置在一个类中，告诉其他人这个变量属于这一个的概念中）
							</p>

							<p>
								<strong>2.17不要添加没用的语境</strong>
							</p>
						</blockquote>
						<p>
							<strong>3 函数</strong>
						</p>

						<blockquote>
							<p>
								<strong>3.1短小</strong>
							</p>

							<blockquote>
								<p>(1) if语句、else语句、while语句等，其中的代码块应该只有一行。所以改行大概应该是一个函数的调用过程。</p>

								<p>(2) 函数不应该大到足以容纳嵌套结构。函数的缩进层次不该多于一层或两层。</p>
							</blockquote>

							<p>
								<strong>3.2函数只做一件事</strong>
							</p>

							<p>
								<strong>3.3每个函数一个抽象层级：函数中的语句都要在同一抽象层级上。</strong>
							</p>

							<blockquote>
								<p>(1) 函数中混杂不同层抽象级别，读者可能无法判断某个表达式是基础概念还是细节。</p>

								<p>(2) 自顶向下读代码，每一个函数后面都跟着位于下一个抽象层级的函数。</p>

								<p>(3) 程序就像一些列To起头的段落。</p>
							</blockquote>

							<p>
								<strong>3.4 switch语句</strong>
							</p>

							<blockquote>
								<p>(1) 无法避免的要写</p>

								<p>(2) 确保每一个switch都埋藏在较低的抽象级别，且永不重复。（即switch去做细节的事情）</p>
							</blockquote>

							<p>
								<strong>3.5使用描述性的名称</strong>
							</p>

							<p>
								<strong>3.6函数参数</strong>
							</p>

							<blockquote>
								<p>(1) 最理想的参数是0，其次是1，再其次是2，避免3个参数。</p>

								<p>(2) 不要使用输出参数（信息通过参数来输出）。</p>

								<p>(3) 如果函数看来需要两个、三个或三个以上参数，就说明其中一些承诺书应该封装为类了。</p>
							</blockquote>

							<p>
								<strong>3.7无副作用</strong>
							</p>

							<p>
								<strong>3.8分隔指令与询问</strong>
							</p>

							<blockquote>
								<p>(1) 函数要么做什么事情，要么回答什么事情，不要都做。</p>
							</blockquote>

							<p>
								<strong>3.9使用异常代替返回错误码，错误处理代码就能从主路径代码中分离出来。</strong>
							</p>

							<p>
								<strong>3.10别重复自己（消除重复）</strong>
							</p>
						</blockquote>
						<p>
							<strong>4 注释</strong>
						</p>

						<blockquote>
							<blockquote>
								<p>(1) 别个糟糕的代码加注释——重新写吧。</p>

								<p>(2) 能用函数或变量时就别用注释。</p>
							</blockquote>
						</blockquote>
						<p>
							<strong>5 格式</strong>
						</p>

						<blockquote>
							<p>
								<strong>5.1格式的目的</strong>
							</p>

							<p>
								<strong>5.2垂直格式</strong>
							</p>

							<blockquote>
								<p>
									(1) 向报纸学习，名称应该告诉我们是否在正确的模板中，源文件最底部应该给出高层次概念和算法，细节应该往下渐进。最重要的概念先出来，指望以包含最少细节的方式表述它们，指望细节最后出来。
								</p>

								<p>(2) 概念间垂直方向上的间隔，不同完整的思路用空白行隔开。</p>

								<p>(3) 垂直方向上的靠近，关系紧密的代码应该相互靠近。</p>

								<p>
									(4) 垂直距离，不要把关系密切的概念放到不同的文件中，对于那些关系密切、放置在同一源文件的概念，它们之间的间隔应该成为相互的易懂度有多重要的衡量标准。变量声明应尽可能靠近其使用位置。函数很短，本地变量应该在函数的顶部出现。实体变量应该在类的顶部声明。相关函数，若某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面。概念相关的代码应该放在一起，相关性越强看，彼此之间的距离就该越短。
								</p>

								<p>(5)垂直顺序。一般而言，我们想自上而下展示函数调用依赖顺序。也就是说，被调用的函数应该放在执行调用的函数下面。</p>
							</blockquote>

							<p>
								<strong>5.3横向格式</strong>
								（这一部分，除了第一个条件，其他都会受到代码格式化工具的影响）
							</p>

							<blockquote>
								<p>(1) 应该尽力保持代码行短小。</p>

								<p>
									(2) 水平方向上区隔与靠近。使用空格字符将彼此紧密相关的事务连接在一起，也用空格把相关性较弱的事物分隔开。可惜的是，多数代码格式化工具都采用相同的运算符空格，所以这种空格间距用的少。
								</p>

								<p>(3) 水平对齐。</p>

								<p>(4) 缩进。</p>
							</blockquote>
						</blockquote>
						<p>
							<strong>6 对象和数据结构</strong>
						</p>

						<blockquote>
							<blockquote>
								<p>
									将变量设置为私有有一个理由：我们不像其他人依赖这些变量。我们还想在心血来潮时能自由修改其他类型或实现。那么，为什么还有那么多程序员给对象自动添加get和set，将私有变量公之于众、如同它们根本就是公共变量一样呢？
								</p>
							</blockquote>

							<p>
								<strong>6.1 数据抽象</strong>
							</p>

							<blockquote>
								<p>
									(1) 隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象！类并不简单地用set和get将其变量推向外面，而是暴露抽象接口，以便用户无需了解数据的实现就能够操作数据本体。我们不愿暴露数据细节，更愿意以抽象形态表述数据。
								</p>
							</blockquote>

							<p>
								<strong>6.2 数据、对象的反对称性</strong>
							</p>

							<blockquote>
								<p>对象把数据隐藏于抽象之后，曝露操作数据的含义。数据结构曝露其数据，没有提供有意义的函数。</p>

								<p>
									过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。
								</p>

								<p>过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。</p>
							</blockquote>

							<p>
								<strong>6.3 得墨忒耳律</strong>
							</p>

							<blockquote>
								<p>(1) 模块不应了解它所操作对象的内部情形。对象不应该通过存取器曝露其内部结构。</p>

								<p>(2) 方法不应调用由任何函数返回的对象的方法。</p>

								<p>(3) 火车失事。（由A通过get得到B，由B通过get得到C，最后由C通过get得到想要的）</p>

								<p>
									(4) 混杂，一半对象，一半数据结构。公共访问器和改值器都把私有变量公开化，诱导外部函数以过程式程序使用数据结构的方式使用这些变量。
								</p>
							</blockquote>

							<p>
								<strong>6.4 数据传送对象</strong>
							</p>

							<blockquote>
								<p>
									最为精炼的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象（DTO，Data Transfer Objects）。
								</p>

								<p>
									对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。
								</p>
							</blockquote>
						</blockquote>
						<p>
							<strong>7 错误处理</strong>
						</p>

						<blockquote>
							<p>
								<strong>7.1使用异常而非返回码</strong>
								（防止因为返回码的判断导致代码逻辑混乱）
							</p>

							<p>
								<strong>7.2 先写Try-Catch-Finally</strong>
							</p>

							<p>
								<strong>7.3 使用不可控异常</strong>
								（不要throws的函数签名，尽量在函数抛出异常位置处理异常）
							</p>

							<p>
								<strong>7.4 给出异常发生的环境说明</strong>
								（应该创建信息充分的错误消息，并和异常一起传递出去）
							</p>

							<p>
								<strong>7.5 依调用者需要定义异常类</strong>
							</p>

							<blockquote>
								<p>
									当我们在应用程序中定义定义异常时，最重要的考虑应该是它们如何被捕获。（书中举了一个例子，第三方的api调用，导致一个函数要捕获多个异常，使用一个包装类包装这个第三方api，让它抛出一个简单的异常，从而简化）
								</p>
							</blockquote>

							<p>
								<strong>7.6 定义常规流程</strong>
								（书中给出一个例子，将一个本来要抛出的异常（异常有指定的操作），放到和正常流程中，当中即把它当做正常流程中的一个特例（面向接口编程））。创建一个类或者配置一个对象，用来处理特例。
							</p>

							<p>
								<strong>7.7 别返回null值</strong>
							</p>

							<p>
								<strong>7.8 更别传递null值</strong>
								（7.7和7.8都是给自己和别人添加麻烦）
							</p>
						</blockquote>
						<p>
							<strong>8 边界</strong>
							（保持软件边界整洁的实践手段和技巧）
						</p>

						<blockquote>
							<p>
								<strong>8.1 使用第三方代码</strong>
							</p>

							<blockquote>
								<p>
									在接口使用者和提供者之间，存在与生俱来的张力。第三方程序包和框架提供者追求普适性，这样就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需要的接口。这种张力会导致系统边界上出现问题。（书中举例，Map的传递，使用泛型可以不需要类型转换，但有时有希望Map不受到泛型影响随意转换，于是他将Map封装到具体的类中，在类的函数自己转换，而不暴露出来转换。但书中也不建议总是以这种方式封装Map的使用。建议不要讲Map（或者边界上的其他接口）在系统中传递。如果你使用类似Map这样的边界接口，就把它保留在类或近亲类中。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API）
								</p>
							</blockquote>

							<p>
								<strong>8.2 浏览和学习边界</strong>
								（第三方的代码编写测试。不要在生产代码中试验新东西，而是编写测试来浏览和理解第三方的代码）
							</p>

							<p>
								<strong>8.3 学习log4j</strong>
							</p>

							<p>
								<strong>8.4 学习性测试的好处不只是免费</strong>
								（免费是指没有代价，不会带来额外的工作）。
							</p>

							<blockquote>
								<p>
									无论你是否需要通过学习性测试来学习，总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界。不使用这些边界测试来减轻迁移的劳力，我们可能会超出应有时限，长久地捆绑在旧版本上面。
								</p>
							</blockquote>

							<p>
								<strong>8.5 使用尚不存在的代码</strong>
								（为尚不知的代码编写合适的接口）
							</p>

							<p>
								<strong>8.6 整洁的边界</strong>
							</p>
						</blockquote>
						<p>
							<strong>9 单元测试</strong>
						</p>

						<blockquote>
							<p>
								<strong>9.1 TDD三定律</strong>
								（测试驱动开发里面有）
							</p>

							<p>
								<strong>9.2 保持测试整洁</strong>
								测试代码和生产代码同样重要。脏测试等于没有测试。问题在于，测试必须随生产代码的演进而修改。
							</p>

							<p>
								<strong>9.3 整洁的测试</strong>
							</p>

							<blockquote>
								<p>不要在测试代码中加入与测试不相干的代码（噪声代码）（given，when，then）。</p>

								<p>
									<strong>9.3.1面向特定领域的测试语言</strong>
									（将API包装成可以阅读的语言（测试语言），但这种测试API并非起初就设计出来，而是在对那些充满令人迷惑细节的测试代码进行后续重构时逐渐演进的）
								</p>

								<p>
									<strong>9.3.2 双重标准</strong>
									（测试代码和生产代码的双重标准）
								</p>
							</blockquote>

							<p>
								<strong>9.4 每个测试一个断言</strong>
							</p>

							<blockquote>
								<p>
									单个断言是一个好的准则。但也不要害怕在单个测试中放入了一个以上断言。应该在单个测试中将断言数量最小化。更好一些的规则或许是每个测试一个概念。
								</p>
							</blockquote>

							<p>
								<strong>9.5 F.I.R.S.T</strong>
							</p>

							<blockquote>
								<p>
									快速Fast（需要频繁的使用测试，所以测试要快）、独立Independent（测试之间相互独立，没有依赖）、可重复Repeatable（测试应当在任何环境下重复通过）、自足验证Self-Validating（红绿）、及时Timely（单元测试应该恰好在使其通过的生产代码之前编写）
								</p>
							</blockquote>
						</blockquote>
						<p>
							<strong>10 类</strong>
						</p>

						<blockquote>
							<p>
								<strong>10.1 类的组织结构</strong>
								（Java类的组织结构先变量后函数，不赘述了）
							</p>

							<p>
								<strong>10.2 类应该短小</strong>
							</p>

							<blockquote>
								<p>
									对于函数，我们通过计算代码行数衡量大小。对于类，我们通过计算权责来衡量大小。类的名称应该描述其权责。命名是帮助判断类的长度的第一个手段。如果无法为某个类命一个精确的名字，这个类大概就太长了。应该能够用大概25个单词描述一个类（不用if、and、or和but等）
								</p>

								<p>
									<strong>10.2.1 单一权责规则</strong>
								</p>

								<blockquote>
									<p>类或者模块应该有且只有一个加以修改的理由（只因为一个责任，去修改这个类）。系统应该由许多短小的类而不是少量巨大的类组成。</p>
								</blockquote>

								<p>
									<strong>10.2.2 内聚</strong>
								</p>

								<blockquote>
									<p>
										类应该至少少量实体变量。内聚性应该保持在一个较高的位置（？？？？？？？？）。保持函数和参数列表短小的策略，有时会导致为一组子集方法所用的实体变量数量增加。出现这种情况时，往往意味着至少有一个类要从大类中挣扎出来。应当尝试将这些变量和方法拆分到两个或更多个类中，让新的类更为内聚。
									</p>
								</blockquote>

								<p>
									<strong>10.2.3 保持内聚性就会得到许多短小的类</strong>
								</p>

								<blockquote>
									<p>将大函数拆分为许多小函数，往往也是将类拆分为多个小类的时机（重构中有许多抽取类的方法，书中以变量类为例子）。</p>
								</blockquote>
							</blockquote>

							<p>
								<strong>10.3 为了修改而组织</strong>
								（对类加以组织，以降低修改的风险）
							</p>
						</blockquote>
						<p>
							<strong>11 系统</strong>
						</p>

						<blockquote>
							<p>
								<strong>11.1 如何建造一个城市</strong>
								（如何在较高的抽象层级-系统层级-上保持整洁）
							</p>

							<p>
								<strong>11.2 将系统的构造与使用分开</strong>
							</p>

							<blockquote>
								<blockquote>
									<p>软件系统应将启始过程与启始过程之后的运行逻辑分离开，在启始过程中构建应用对象，也会存在互相缠结的依赖关系。</p>

									<p>每一个应用都应该留意启始过程。（书中给出一个延迟初始化的例子）</p>
								</blockquote>

								<p>
									<strong>11.2.1 分解main</strong>
								</p>

								<blockquote>
									<p>
										将构造与使用分开的方法之一是将全部构造过程搬迁到main或被称之为main的模块中，设计系统的其余部分时，假设所有对象都已正确构造和设置。main函数创建系统所需的对象，在传递给应用程序，应用程序只管使用。
									</p>
								</blockquote>

								<p>
									<strong>11.2.2 工厂</strong>
								</p>

								<blockquote>
									<p>有时应用程序也要负责何时创建对象。（书中例子，抽象工厂）</p>
								</blockquote>

								<p>
									<strong>11.2.3 依赖注入</strong>
									（关于依赖注入，看看Spring比较好）
								</p>

								<blockquote>
									<p>
										依赖注入/控制反转是一种强大的实现分离构造和使用的机制。控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循单一权责原则。在依赖管理情景中，对象不应该负责实体化对自身的依赖。反之，它应当将这份权责交付给其他“有权利”的机制，从而实现控制的反转。因为初始设置是一种全局问题，这种授权机制通常是main例程，要么是特定目的的容器。
									</p>

									<p>
										类不直接分解其依赖，而是完全被动的。它提供可用于注入依赖的赋值器方法或构造器参数。在构造过程中，DI容器实体化需要的对象，并使用构造器参数或赋值器方法将依赖连接在一起。
									</p>
								</blockquote>
							</blockquote>

							<p>
								<strong>11.3 扩容</strong>
							</p>

							<blockquote>
								<p>
									“一开始就作对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。
								</p>

								<p>
									（书中使用了EJB1和EJB2的使用来说明。业务逻辑与EJB2应用“容器”紧密耦合，你必须子类化容器类型，必须提供许多个该容器所需要的生命周期方法。由于存在这种与重量级容器的紧耦合，隔离单元测试就很困难。）
								</p>
							</blockquote>

							<blockquote>
								<p>
									<strong>横贯式关注面</strong>
								</p>
								<p>持久化类的关注面倾向于横贯某个领域的天然对象边界。你会想用同样的策略来持久化所有对象。</p>

								<p>
									AOP（面向切面编程）是一种恢复贯穿式关注面模块化的普适手段。在AOP中，被称为切面的模块构造指明了系统中安歇点的行为会以某种一致的方式被修改，从而支持某种特定的场景。以持久化为例，可以声明哪些对象和属性（或其模块）应当被持久化，然后将持久化任务委托给持久化框架。行为的修改由AOP框架以无损方式在目标代码中进行。
								</p>
							</blockquote>

							<p>
								<strong>11.4 Java代理</strong>
								（需要了解Java反射的原理）
							</p>

							<p>
								<strong>11.5 纯Java AOP框架</strong>
								（Spring AOP和JBoss AOP）
							</p>

							<p>
								<strong>11.6 AspectJ的方面</strong>
							</p>

							<p>
								<strong>11.7 测试驱动系统框架</strong>
							</p>

							<blockquote>
								<p>
									假设你能用POJO（Plain Old Java Objects，简单Java对象）编写应用程序的领域逻辑，在代码层面与框架关注面分开，就可能真正地用测试来驱动架构。
								</p>

								<p>
									最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java（或其他语言）对象实现。不同的领域之间用最不具有侵害性的切面或类切面工具整合起来。这种架构就能测试驱动，就像代码一样。
								</p>
							</blockquote>

							<p>
								<strong>11.8 优化策略</strong>
							</p>

							<blockquote>
								<p>拥有模块化关注面的POJO系统提供的敏捷能力，允许我们基于最新的知识做出优化的、时机刚好的决策。决策的复杂性也降低了。</p>
							</blockquote>

							<p>
								<strong>11.9 明智使用添加了可论证价值的标准</strong>
							</p>

							<blockquote>
								<p>
									有了标准，就更容易服用想法和组件、雇佣拥有相关经验的人才、封装好点子，以及将组件连接起来。不过，创立标准的过程有时却漫长到行业等不及的程度，有些标准没能与它要服务的采用者的真实需求相结合。
								</p>
							</blockquote>

							<p>
								<strong>11.10 系统需要领域特定语言</strong>
								（最近Martin Fowler出了一本书《领域特定语言”》，虽然我还没机会看，但是应该还不错）
							</p>
						</blockquote>
						<p>
							<strong>12 迭进</strong>
						</p>

						<blockquote>
							<p>
								<strong>12.1 通过迭进设计达到整洁目的</strong>
							</p>

							<blockquote>
								<p>据Kent所述（Kent Back）只要遵循以下规则，设计就能变得“简单”：</p>

								<p>(1)  运行所有测试</p>

								<p>(2)  不可重复</p>

								<p>(3)  表达了程序员的意图</p>

								<p>(4)  尽可能减少类和方法的数量</p>
							</blockquote>

							<p>
								<strong>12.2 简单设计规则1：运行所有测试</strong>
							</p>

							<p>
								<strong>12.3 简单设计规则2~4：重构</strong>
							</p>

							<blockquote>
								<p>有了测试，就能保持代码和类的整洁，方式就是递增式地重构代码。（测试消除对清理代码就会破坏代码的恐惧）</p>

								<p>
									在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等。
								</p>
							</blockquote>

							<p>
								<strong>12.4 不可重复</strong>
							</p>

							<blockquote>
								<p>重复是拥有良好设计系统的大敌。它代表着额外的工作，额外的风险和额外且不必要的复杂度。</p>
							</blockquote>

							<p>
								<strong>12.5 表达力</strong>
							</p>

							<blockquote>
								<p>代码应当清晰地表达其作者的意图。作者把代码写得越清晰，其他人花在理解代码上时间也就越少，从而减少缺陷，缩减维护成本。</p>

								<p>(1)  选用好名字</p>

								<p>(2)  保持函数和类的尺寸短小</p>

								<p>(3)  采用标准命名法（在类名中采用标准的设计模式名）</p>

								<p>(4)  单元测试也要具有好的表达性，以起到文档的作用</p>
							</blockquote>

							<p>
								<strong>12.6 尽可能少的类和方法</strong>
							</p>

							<blockquote>
								<p>防止由毫无意义的教条主义导致的。当然这一点是关于简单设计的四条原则里面优先级最低的一条。</p>
							</blockquote>
						</blockquote>
					</blockquote>
				</div>
				<div id="comments">
					<!-- Duoshuo Comment BEGIN -->
					<div class="ds-thread"></div>
					<script type="text/javascript">
					var duoshuoQuery = {short_name:"benzeph"};
						(function() {
							var ds = document.createElement('script');
							ds.type = 'text/javascript';ds.async = true;
							ds.src = 'http://static.duoshuo.com/embed.js';
							ds.charset = 'UTF-8';
							(document.getElementsByTagName('head')[0] 
							|| document.getElementsByTagName('body')[0]).appendChild(ds);
						})();
					</script>
					<!-- Duoshuo Comment END -->
				</div>
			</div>
		</div>
	</div>
	<script type="text/javascript" src="../js/bootstrap.min.js"></script>
	<script type="text/javascript" src="../js/jquery.min.js"></script>
	<script type="text/javascript" src="../js/jquery.min.js"></script>
	<script type="text/javascript" src="../js/jquery.scrollUp.min.js"></script>
	<script type="text/javascript">
		$(function () {
			$.scrollUp();
		});
	</script>
</body>
</html>